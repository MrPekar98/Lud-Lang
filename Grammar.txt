<Start> -> <Imports> <Program>
	 | <Imports>
	 | <Program>
	 | 'lambda'
	 
<Var> -> 'variable'

<Imports> -> import <path> <Imports>
	   | 'lambda'

<Program> -> <ProtocolDecl> <Program>
	   | <ClassDecl> <Program>
	   | 'lambda'
	   
<ProtocolDecl> -> protocol <Var> [-> <Var>] { <Statements> } <ProtocolDecl>
	        | 'lambda'

<ClassDecl> -> class <Var> [-> <Var>] [using <Var> {, <Var>}] { <Statements> } <ClassDecl>
	     | 'lambda'

<Statements> -> <Statement> <Statements>
	      | 'lambda'

<Statement> -> <VarDecl>
	     | <MethodDecl>
	     | <Constructor>
	     | <Assignment>
	     | <Expression>
	     | <IfStatement>
	     | <ForEach>
	     | <WhileLoop>
	     | <ForLoop>
	     | 'lambda'
	     
<VarDecl> -> <Accessor> [static] [const] <Assignemnt> : <DataType>

<Accessor> -> public
	    | private
	    | internal
	    | 'lambda'
	    
<DataType> -> num
	    | string
	    | bool
	    | char

<Assignment> -> <Var> = <Expression>
	      | this.<Var> = <Expression>
	      | super.<Var> = <Expression>
	      | this.<Var>
	      | super.<Var>
	      | <Var>

<Expression> -> <ArithExpression>
	      | create <Var>([<Expression> {, <Expression>}])

<ArithExpression> -> <BoolXor> | <ArithExpression>
		   | <ArithExpression>
		   | <Var>++
		   | <Var>--

<BoolXor> -> <BoolAnd> ^ <BoolXor>
	   | <BoolAnd>

<BoolAnd> -> <ArithNumberString> & <BoolAnd>
	   | <ArithNumberString>

<ArithNumberString> -> <PlusMinus> % <ArithExpression>
	      	     | <PlusMinus>

<PlusMinus> -> <MultDiv> + <PlusMinus>
	     | <MultDiv> - <PlusMinus>
	     | <MultDiv>

<MultDiv> -> <ArithPow> * <MultDiv>
	   | <ArithPow> / <MultDiv>
	   | <ArithPow>

<ArithPow> -> <ArithParan>^<ArithExpression>

<ArithParan> -> (<ArithExpression>)
	      | 'number'
	      | 'string'
	      | 'boolean'
	      | 'char'
	      | <Var>
	      | this.<Var>
	      | super.<Var>
	      | this.<Var>(<Expression> {, <Expression>})
	      | super.<Var>(<Expression> {, <Expression>})
	      | <Var>(<Expression> {, <Expression>})

<IfStatement> -> if (<BoolExpression>) { <Statements> } <Else>

<Else> -> else if (<BoolExpression>) { <Statements> } <Else>
	| else { <Statements> }
	| 'lambda'

<ForEach> -> foreach (<Var> : <DataType> in <Var>) { <Statements> }

<WhileLoop> -> while ( <BoolExpression> ) { <Statements> }

<ForLoop> -> for (<Var> = <Expression>; <BoolExpression>; <Expression>) { <Statements> }
	   | for (<Var> = <Expression> : <DataType>; <BoolExpression>; <Expression>) { <Statements> }

<MethodDecl> -> <Accessor> [static] <Var>([<Var> : <DataType> {, <Var> : <DataType>}]) : void { <Statements> }
	      | <Accessor> [static] <Var>([<Var> : <DataType> {, <Var> : <DataType>}]) : <DataType> { <Statements> return <Expression> }

<Constructor> -> <Accessor> constructor([<Var> : <DataType> {, <Var> : <DataType>}]) { <Statements> }
